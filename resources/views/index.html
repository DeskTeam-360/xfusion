<script>
    (function () {
      function canvasToImgClone(sourceRoot, cloneRoot) {
        const sourceCanvases = sourceRoot.querySelectorAll('canvas');
        const cloneCanvases  = cloneRoot.querySelectorAll('canvas');
        sourceCanvases.forEach((cv, i) => {
          try {
            // ensure chart is rendered; if needed, you can delay capture slightly
            const dataURL = cv.toDataURL('image/png'); 
            const img = document.createElement('img');
            // keep sizing consistent with your fixed canvas size
            const w = cv.getAttribute('width')  || cv.width  || 600;
            const h = cv.getAttribute('height') || cv.height || 600;
            img.width = w; img.height = h; img.src = dataURL;
            if (cloneCanvases[i]) cloneCanvases[i].replaceWith(img);
          } catch(e) {
            // if canvas is tainted or not ready, we just leave the canvas as-is
          }
        });
      }

      function printOnly(selector) {
        const source = document.querySelector(selector);
        if (!source) { alert('Printable element not found: ' + selector); return; }

        // Clone the report content
        const clone = source.cloneNode(true);
        // Replace canvases with images so they reliably print
        canvasToImgClone(source, clone);

        // Create hidden iframe as a clean print document
        const iframe = document.createElement('iframe');
        iframe.style.position = 'fixed';
        iframe.style.right = '0';
        iframe.style.bottom = '0';
        iframe.style.width = '0';
        iframe.style.height = '0';
        iframe.style.border = '0';
        document.body.appendChild(iframe);

        const doc = iframe.contentDocument || iframe.contentWindow.document;
        doc.open();
        doc.write(`
          <!doctype html>
          <html>
            <head>
              <meta charset="utf-8">
              <title>Report PDF</title>
              <style>
                html, body {
                  margin: 0;
                  margin-left: -1.5rem;
                  padding: 0;
                  font-family: "Bebas Neue", Arial, sans-serif;
                  font-size: 18px !important;
                  background: #fff;
                  color: #000;
                  width: 100%;
                }

                body {
                  /* give wide content area */
                  padding: 10mm 15mm; /* adjust margins: top/bottom, left/right */
                }

                .grit-for-print {
                  width: 100%;
                  max-width: 100%; /* remove any Elementor limits */
                }

                .print-page {
                  width: 100%;
                  max-width: 100%;
                  page-break-after: always;
                  page-break-inside: avoid;
                }

                .print-page:last-child {
                  page-break-after: auto;
                }
              </style>
            </head>
            <body></body>
          </html>
        `);
        doc.close();

        // Insert cloned content into the clean print doc
        doc.body.appendChild(clone);

        // Wait for images (including canvas snapshots) before printing
        const images = doc.images;
        const waits = [];
        for (let i = 0; i < images.length; i++) {
          waits.push(new Promise(res => {
            if (images[i].complete) return res();
            images[i].addEventListener('load',  res, { once:true });
            images[i].addEventListener('error', res, { once:true });
          }));
        }

        Promise.all(waits).then(() => {
          iframe.contentWindow.focus();
          iframe.contentWindow.print();
          
          // Generate PDF and save to storage
          generateAndSavePDF(iframe, doc);
          
          // clean up
          setTimeout(() => document.body.removeChild(iframe), 1000);
        });
      }

      // Function to generate PDF and save to storage
      function generateAndSavePDF(iframe, doc) {
        try {
          // Get user ID from the page (you may need to adjust this selector)
          const userIdElement = document.querySelector('[data-user-id]') || 
                               document.querySelector('#user_id') || 
                               document.querySelector('input[name="user_id"]');
          
          if (!userIdElement) {
            console.error('User ID not found. Please add data-user-id attribute to an element or include user_id input.');
            return;
          }
          
          const userId = userIdElement.value || userIdElement.getAttribute('data-user-id');
          
          if (!userId) {
            console.error('User ID is empty');
            return;
          }

          // Generate PDF using html2pdf or similar library
          // For now, we'll use a simple approach with jsPDF
          if (typeof html2pdf !== 'undefined') {
            // Using html2pdf library
            const element = doc.body;
            const opt = {
              margin: 10,
              filename: `report_${userId}_${Date.now()}.pdf`,
              image: { type: 'jpeg', quality: 0.98 },
              html2canvas: { scale: 2 },
              jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
            };

            html2pdf().set(opt).from(element).save().then(() => {
              // After PDF is generated, upload it
              uploadGeneratedPDF(userId, opt.filename);
            });
          } else {
            // Fallback: Use browser's print to PDF and then upload
            console.log('html2pdf library not found. Using print method.');
            // You can implement alternative PDF generation here
          }
        } catch (error) {
          console.error('Error generating PDF:', error);
        }
      }

      // Function to upload generated PDF
      function uploadGeneratedPDF(userId, filename) {
        // Capture the content as canvas and convert to PDF
        const sourceElement = document.querySelector('.grit-for-print');
        if (!sourceElement) {
          console.error('Source element not found');
          return;
        }

        // Use html2canvas to capture the content
        if (typeof html2canvas !== 'undefined') {
          html2canvas(sourceElement, {
            scale: 2,
            useCORS: true,
            allowTaint: true,
            backgroundColor: '#ffffff'
          }).then(canvas => {
            // Convert canvas to blob
            canvas.toBlob(function(blob) {
              // Create a simple PDF with the image
              createPDFFromCanvas(canvas, userId, filename, blob);
            }, 'image/png');
          }).catch(error => {
            console.error('Error capturing canvas:', error);
            showUploadMessage('Error generating PDF: ' + error.message, 'error');
          });
        } else {
          // Fallback: Create a simple PDF
          createSimplePDF(userId, filename);
        }
      }

      // Function to create PDF from canvas
      function createPDFFromCanvas(canvas, userId, filename, imageBlob) {
        // For now, we'll upload the image as a PDF
        // In a real implementation, you'd convert the image to PDF format
        const file = new File([imageBlob], filename.replace('.pdf', '.png'), { type: 'image/png' });

        // Upload the image file
        uploadPDFDirectly(file, userId, 'Generated report image');
      }

      // Function to create a simple PDF
      function createSimplePDF(userId, filename) {
        // Create a simple PDF content
        const pdfContent = createSimplePDFContent(userId);
        const blob = new Blob([pdfContent], { type: 'application/pdf' });
        const file = new File([blob], filename, { type: 'application/pdf' });

        // Upload using our existing function
        if (typeof uploadPdfResult !== 'undefined') {
          uploadPdfResult(file, userId, 'Auto-generated report PDF')
            .then(data => {
              console.log('PDF uploaded successfully:', data);
              showUploadMessage('PDF generated and saved successfully!', 'success');
            })
            .catch(error => {
              console.error('Upload failed:', error);
              showUploadMessage('PDF generated but upload failed: ' + error.message, 'error');
            });
        } else {
          // Fallback: Use direct AJAX upload
          uploadPDFDirectly(file, userId);
        }
      }

      // Function to create simple PDF content
      function createSimplePDFContent(userId) {
        const reportData = {
          userId: userId,
          timestamp: new Date().toISOString(),
          title: 'Generated Report'
        };

        // Simple PDF structure
        return `%PDF-1.4
1 0 obj
<<
/Type /Catalog
/Pages 2 0 R
>>
endobj

2 0 obj
<<
/Type /Pages
/Kids [3 0 R]
/Count 1
>>
endobj

3 0 obj
<<
/Type /Page
/Parent 2 0 R
/MediaBox [0 0 612 792]
/Contents 4 0 R
/Resources <<
/Font <<
/F1 <<
/Type /Font
/Subtype /Type1
/BaseFont /Helvetica
>>
>>
>>
>>
endobj

4 0 obj
<<
/Length 200
>>
stream
BT
/F1 16 Tf
72 720 Td
(${reportData.title}) Tj
0 -30 Td
/F1 12 Tf
(User ID: ${reportData.userId}) Tj
0 -20 Td
(Generated: ${reportData.timestamp}) Tj
0 -40 Td
(This is an auto-generated PDF report) Tj
ET
endstream
endobj

xref
0 5
0000000000 65535 f 
0000000009 00000 n 
0000000058 00000 n 
0000000115 00000 n 
0000000204 00000 n 
trailer
<<
/Size 5
/Root 1 0 R
>>
startxref
453
%%EOF`;
      }

      // Direct AJAX upload function
      function uploadPDFDirectly(file, userId, comment = '') {
        const formData = new FormData();
        formData.append('pdf_result', file);
        formData.append('user_id', userId);
        if (comment) {
          formData.append('comment', comment);
        }

        const xhr = new XMLHttpRequest();
        
        xhr.addEventListener('load', function() {
          if (xhr.status === 200) {
            const response = JSON.parse(xhr.responseText);
            if (response.success) {
              console.log('PDF uploaded successfully:', response.data);
              showUploadMessage('PDF generated and saved successfully!', 'success');
            } else {
              console.error('Upload failed:', response.message);
              showUploadMessage('Upload failed: ' + response.message, 'error');
            }
          } else {
            console.error('Upload failed with status:', xhr.status);
            showUploadMessage('Upload failed with status: ' + xhr.status, 'error');
          }
        });

        xhr.addEventListener('error', function() {
          console.error('Network error during upload');
          showUploadMessage('Network error during upload', 'error');
        });
        const domain = window.location.hostname;
        

        xhr.open('POST', "https://admin."+domain + '/api/save-pdf-result');
        xhr.send(formData);
      }

      // Function to show upload messages
      function showUploadMessage(message, type) {
        // Create or update message element
        let messageEl = document.getElementById('pdf-upload-message');
        if (!messageEl) {
          messageEl = document.createElement('div');
          messageEl.id = 'pdf-upload-message';
          messageEl.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            z-index: 10000;
            max-width: 300px;
            word-wrap: break-word;
          `;
          document.body.appendChild(messageEl);
        }

        messageEl.textContent = message;
        messageEl.style.backgroundColor = type === 'success' ? '#28a745' : '#dc3545';
        
        // Auto-hide after 5 seconds
        setTimeout(() => {
          if (messageEl && messageEl.parentNode) {
            messageEl.parentNode.removeChild(messageEl);
          }
        }, 5000);
      }

      // Hook the button
      document.addEventListener('click', function (e) {
        if (e.target && e.target.id === 'printReportBtn') {
          // If your Chart.js just rendered, a tiny delay helps ensure canvas is ready
          requestAnimationFrame(() => requestAnimationFrame(() => printOnly('.grit-for-print')));
        }
      });
    })();
    </script>